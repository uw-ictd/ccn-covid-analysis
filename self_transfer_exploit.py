""" Computes the impact of the self-transfer exploit and a list of transactions
untainted by the exploited funds.
"""

from collections import defaultdict
from datetime import datetime

import altair
import pandas as pd

import infra.constants
import infra.platform
import infra.pd


def compute_self_transfer_frequency():
    transactions = infra.pd.read_parquet("data/clean/transactions_DIV_none_INDEX_timestamp.parquet")
    transfers = transactions.loc[(transactions["kind"] == "user_transfer") | (transactions["kind"] == "admin_transfer")]

    transfers = transfers.astype({
        "user": object,
        "dest_user": object
    })

    self_transfers = transfers.loc[(transfers["user"] == transfers["dest_user"])].reset_index()
    # Don't count the accidental self-transfers that did not exploit the bug
    self_transfers = self_transfers.loc[self_transfers["timestamp"] > datetime.strptime('2020-05-01 00:00:00', '%Y-%m-%d %H:%M:%S')]
    print(self_transfers["user"].unique())
    print(len(self_transfers["user"].unique()))

    self_transfers["day_bin"] = self_transfers["timestamp"].dt.floor("d")
    self_transfers = self_transfers.groupby(["day_bin"]).sum().reset_index()

    print(self_transfers)


def trace_dirty_funds():
    transactions = infra.pd.read_parquet("data/clean/transactions_DIV_none_INDEX_timestamp.parquet").reset_index()

    min_date = datetime.strptime('2020-05-24 00:00:00', '%Y-%m-%d %H:%M:%S')
    fix_date = datetime.strptime('2020-06-11 00:00:00', '%Y-%m-%d %H:%M:%S')

    dirty_balances = defaultdict(int)
    dirty_users = {}
    clean_transactions = []

    for transaction in transactions.itertuples():
        # Transfers outside the exploit window are clean
        if transaction.timestamp < min_date or transaction.timestamp >= fix_date:
            clean_transactions.append(transaction)
            continue

        # Evaluate and trace all transactions within th exploit window
        if transaction.user == transaction.dest_user:
            # Self-transfers create dirty money
            dirty_balances[transaction.user] += transaction.amount_idr
            if transaction.user not in dirty_users:
                dirty_users[transaction.user] = transaction.timestamp

        elif ((transaction.kind == "admin_transfer" or transaction.kind == "user_transfer") and
            (dirty_balances[transaction.user] > 0)):
            # If the user transfers dirty money to another user, the new user also becomes dirty
            dirty_balances[transaction.user] -= transaction.amount_idr
            dirty_balances[transaction.user] = max(dirty_balances[transaction.user], 0)

            dirty_balances[transaction.dest_user] += transaction.amount_idr
            if transaction.dest_user not in dirty_users:
                dirty_users[transaction.dest_user] = transaction.timestamp

        elif transaction.kind == "purchase" and dirty_balances[transaction.user] > 0:
            # If the user spends dirty money, the money is used up
            dirty_balances[transaction.user] -= transaction.amount_idr
            dirty_balances[transaction.user] = max(dirty_balances[transaction.user], 0)

        else:
            # Remaining transactions are clean
            clean_transactions.append(transaction)

    print("The users who exploited or were given exploited money are:", dirty_users)
    print("There are", len(dirty_users), "users impacted by the exploit.")
    untainted_transactions = pd.DataFrame(clean_transactions)
    untainted_transactions = untainted_transactions.drop("Index", axis=1)
    print(untainted_transactions)
    untainted_transactions = untainted_transactions.set_index("timestamp")

    infra.pd.clean_write_parquet(untainted_transactions, "data/derived/untainted_transactions_INDEX_timestamp.parquet")


if __name__ == "__main__":
    # Module specific format options
    pd.set_option('display.max_columns', None)
    pd.set_option('display.max_colwidth', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_rows', 40)

    compute_self_transfer_frequency()
    trace_dirty_funds()

    print("Done!")
